package floorplans;
import java.util.*;
import java.awt.geom.Line2D;

import processing.core.PApplet;
import processing.data.XML;
import java.util.UUID;
import static java.lang.Math.pow;

public class NodeGeometry{
  PApplet parent;
  public ArrayList<Integer> X;
  public ArrayList<Integer> Y;
  public ArrayList<Line2D.Float> L;
  public ArrayList<Integer> D;
  // indice della connessione, tra le connesioni globali, a cui appartiene la porta i-esima (D).
  public ArrayList<Integer> C;
  // UUID di tutte le porte. le uso per stamparle e per associarle ai linesegment.
  public ArrayList<UUID> D_U;
  //TODO COSA E RESOLUTION? LA HO INVENTATA
  // TODO VA CAMBIATA
  public int resolution = Globals.resolution;
  private int x1,y1;
  
  private int maxX=0, maxY=0, minX=0, minY=0;
  
  NodeGeometry(PApplet _parent){
  this.parent = _parent;
  X = new ArrayList<Integer>();
  Y = new ArrayList<Integer>();
  L = new ArrayList<Line2D.Float>();
  // Porte
  D = new ArrayList<Integer>();
  C = new ArrayList<Integer>();
  D_U = new ArrayList<UUID>();
  }
  
  void addPoint(int x, int y) {
    //TODO NON SO COSA SONO
      X.add(x);
      Y.add(y);
      if (X.size() != 1) {
        L.add(new Line2D.Float(x,y,x1,y1));
      }
      x1 = x;
      y1 = y;
  }
  
  void addDoor(int x, int y) {
	  // TODO LA PORTA E' UN PUNTO: VA RESA UN SEGMENTO.
	  // TODO LA PORTA DEVE AVERE UN MATCHING CON GLI ALTRI PUNTI PIU DIFFICILE.
      D.add(this.pointIndex(x, y));
      D_U.add(UUID.randomUUID());

  }
  
  void addConnection(int c){
	  C.add(c);
  }
  
  int lineSize() {
    return L.size();
  }
  
  // restituisce l'indice di un punto se è parte dell'offset. -1 al contrario.
  int pointIndex(int x, int y) {
  int tmpX,tmpY;
  for (int i=0; i < X.size(); i++) {
    tmpX = X.get(i);
    tmpY = Y.get(i);
    if  (pow(tmpX-x,2)+pow(tmpY-y,2) < Globals.p_distance*Globals.p_distance) {
      return i;
    }
  }
  return -1;
  }
  
  void movePoint(int directions){
	  int index =this.X.size() -1;
	  // 1 su 2 giu 3 dx 4 sx 
	  switch (directions) {
	  case 1: 
		  Y.set(index,Y.get(index)-Globals.step);
		  L.get(L.size()-1).y1 -= (float)Globals.step;
		  break;
	  case 2: 
		  Y.set(index,Y.get(index)+Globals.step);
		  L.get(L.size()-1).y1 += (float)Globals.step;
		  break;
	  case 3: 
		  X.set(index,X.get(index)+Globals.step);
		  L.get(L.size()-1).x1 += (float)Globals.step;
		  break;
	  case 4: 
		  X.set(index,X.get(index)-Globals.step);
		  L.get(L.size()-1).x1 -= (float)Globals.step;
		  break;
	  }
	  //TODO MUOVO SU SIA IL PUNTO CHE QUELLI CHE CI SONO PRIMA
  }
  
  void setLastX(int nx) {
	  // TODO FARE sia linea che punto
 	  X.set(X.size()-1, nx);
	  L.get(L.size()-1).x1=(float)nx;
	  x1 = nx;
	  }
 
  void setLastY(int ny) {
	  // TODO Fare sia linea che punto
	  Y.set(Y.size()-1, ny);
	  L.get(L.size()-1).y1=(float)ny;
	  y1 = ny;
	  }
  
  void display(){
	  parent.stroke(10);
	  // stampo le linee
	  if (X.size() <= 1)
		  return;
	  for (int i=1; i < X.size(); i++){
		    //TODO
		    parent.line(Math.round(L.get(i-1).getX1()),Math.round(L.get(i-1).getY1()),Math.round(L.get(i-1).getX2()),Math.round(L.get(i-1).getY2()));
		    //line(X.get(i-1),Y.get(i-1),X.get(i),Y.get(i));
		    parent.ellipse(X.get(i-1),Y.get(i-1),5,5);
		    parent.ellipse(X.get(i),Y.get(i),5,5);
		  }
  }
  
  void displayDoors(){
	    //parent.fill(239,192,167);
	   	parent.fill(255);
	    for (int j=0; j < D.size();j++){
	    	int i = D.get(j);
	    	parent.rect(X.get(i)-5,Y.get(i)-5,10,10);
	    	}
  }
 
  boolean closedRoom(){
	  if (this.X.size()<3)
		  return false;
	  int tmpX1 = X.get(0);
	  int tmpY1 = Y.get(0);
	  int tmpX2 = X.get(X.size()-1);
	  int tmpY2 = Y.get(Y.size()-1);
	  if  (pow(tmpX1-tmpX2,2)+pow(tmpY1-tmpY2,2) < Globals.p_distance*Globals.p_distance) {
		  // TODO la linea che va dal primo all'ultimo c'è già?
	      return true;
	      }
	  return false;
  }
 
  void removeLastPoint(){
	  x1 = X.get(X.size()-2);
	  y1 = Y.get(Y.size()-2);
	  X.remove(X.size()-1);
	  Y.remove(Y.size()-1);
	  L.remove(L.size()-1);
  }
  /*int changePoint(int index, int x, int y) {
  X.get(i) = x;
  Y.get(i) = y;
  if (i != 0) {
    // se i è il primo cambio solo quello. Se i è l'ultimo idem.
    //Se invece è uno in mezzo devo cambiare due segmenti. E poi fare backtracking.
  }
  } 
  */
  void toXML(XML xml){
//
//	     XML Xnode = xml.addChild("node");
//	     XML Xid = Xnode.addChild("id");
//	     Xid.setContent(Integer.toString(id));
//	     XML Xlabel = Xnode.addChild("label");
//	     Xlabel.setContent(l.name);
//	     XML Xtype = Xnode.addChild("type");
//	     Xtype.setContent(l.type);
//	     XML Xcolor = Xnode.addChild("color");
//	     Xcolor.setInt("r",r);
//	     Xcolor.setInt("g",g);
//	     Xcolor.setInt("b",b);
//	     XML Xpose = Xnode.addChild("position");
//	     Xpose.setInt("x",x);
//	     Xpose.setInt("y",y);
//	     // TODO FARE
//	     XML Xpoints = Xnode.addChild("spaces");
//	     // TODO da fare: anche stampare connections
	  computeBoundingBox();
	  XML bb = xml.addChild("bounding_box");
	  XML xMaxX = bb.addChild("maxx");
	  pointXML(xMaxX,maxX);
	  XML xMaxY = bb.addChild("maxy");
	  pointXML(xMaxY,maxY);
	  XML xMinX = bb.addChild("minx");
	  pointXML(xMinX,minX);
	  XML xMinY = bb.addChild("minY");
	  pointXML(xMinY,minY);
	  XML polygon = xml.addChild("bounding_polygon");
	  for (int i=0;i<X.size(); i++) {
		  pointXML(polygon,i);
	  }
	  XML lines = xml.addChild("space_representation");
	  for (int i=0;i<L.size();i++) {
		  lineXML(lines,i);
	  }
	  XML portals = xml.addChild("portals");
	  connectionsXML(portals);
	  }
  
  private void connectionsXML(XML xml){
	  for(int i=0; i<D.size(); i++){
		  //TODO RENDERLA HORIZONTAL O VERTICAL IMPLICIT O ESPLICIT
		  XML portal = xml.addChild("portal");
		  XML c_id = portal.addChild("id");
		  c_id.setContent(D_U.toString());
		  XML classxml = portal.addChild("class");
		  classxml.setContent("HORIZONTAL");
		  XML typexml = portal.addChild("type");
		  typexml.setContent("EXPLICIT");
		  XML direction = portal.addChild("direction");
		  direction.setContent("BOTH");
	  }
	  
	  XML other_room = xml.addChild("target");
  }
  private void computeBoundingBox(){
	  for (int i=1; i<X.size();i++){
		  if (X.get(i)>=X.get(maxX))
			  maxX = i;
		  if (X.get(i)<=X.get(minX))
			  minX = i;
		  if (Y.get(i)>=X.get(maxY))
			  maxY = i;
		  if (Y.get(i)<=X.get(minY))
			  minY = i;
	  }
  }
  
  private void pointXML(XML xml,int i){
	   XML xpoint = xml.addChild("point");
	   xpoint.setInt("x",X.get(i));
	   xpoint.setInt("y",Y.get(i));
  }
  private void pointXML(XML xml,int x,int y){
	   XML xpoint = xml.addChild("point");
	   xpoint.setInt("x",x);
	   xpoint.setInt("y",y);
 }
  
  private void lineXML(XML xml, int index){
	  UUID tmpID;
	  Line2D.Float tmpLine = L.get(index);
	  int x1 = (int) tmpLine.getX1();
	  int x2 = (int) tmpLine.getX2();
	  int y1 = (int) tmpLine.getY1();
	  int y2 = (int) tmpLine.getY2();
	  int isdoor = -1;
	  for (int i=0; i<D.size(); i++) {
		  if ((X.get(i) == x1)&&(Y.get(i)==y1)){
			  isdoor = i;
			  break;
		  }
	  }
	  // TODO QUESTO VA RIMOSSO E AGGIUNGO IN MODO PIU PRECISO.
	  // TODO CHECK
	  if (isdoor != -1) {
		  //ho trovato l'index, è una porta, la aggiungo.
			 // altrimenti e' una porta.
			 //SE E' UNA PORTA ALLORA AGGIUNGO UN ALTRO SEGMENTO FITTIZIO.
		  XML doorLinesegment = xml.addChild("linesegment");
		  tmpID= D_U.get(D.indexOf(isdoor));
		  doorLinesegment.setString("id",tmpID.toString());
		  pointXML(doorLinesegment,isdoor);
		  pointXML(doorLinesegment,isdoor);
		  XML lclassxml = xml.addChild("class");
		  lclassxml.setContent("PORTAL");
		  XML ltypexml = xml.addChild("type");
		  ltypexml.setContent("EXPLICIT");
		  
	  }
	  else {
		  XML linesegment = xml.addChild("linesegment");
		  tmpID = UUID.randomUUID();
		  linesegment.setString("id",tmpID.toString());
		  pointXML(linesegment,x1,y1);
		  pointXML(linesegment,x2,y2);
		  XML lclassxml = xml.addChild("class");
		  lclassxml.setContent("WALL");
		  XML ltypexml = xml.addChild("type");
		  ltypexml.setContent("EXPLICIT");
	  }
  }
  public void addDoorUID(int x, int y, UUID uid)
  {
      int index  = D.indexOf(this.pointIndex(x, y));
      D_U.set(index, uid);
 	 
  }
}