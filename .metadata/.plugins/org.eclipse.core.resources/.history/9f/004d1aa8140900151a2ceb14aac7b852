package floorplans;

import processing.core.*;
import processing.data.XML;

import java.awt.geom.Line2D;
import java.io.File;
import java.util.*;

public class FloorPlanSketch extends PApplet {


	PImage img;
	// grandezza x e y dell'immagine + grandezza pannello dx
	String filename = "/Users/matteoluperto/Documents/eclipseworkspace/floorplans/poli.png";
	int x_dim=1100, y_dim=700;
	int x2_dim = 300;
	// width e height original dell'immagine
	int x;
	int y;
	// diametro degli ellissi generati
	// MESSO IN GLOBALS
	//int shape = 15;
	// nodi disegnati
	ArrayList<Node>  n = new ArrayList<Node>();
	ArrayList<Connection> c = new ArrayList<Connection>();
	// penultimo e ultimo nodo selezionato
	int last = -1;
	int lastbu = -1;
	// label / colore selezionato
	int current_label = -1;
	// MESSO IN GLOBALS
	//int opacity1 = 130, opacity2 = 255;

	// last_inser vale 0 se non ho fatto nulla. se vale 1 ho inserito un nodo; se vale 2 ho inserito un arco;
	int last_insert = 0;

	// tolerance value for point-to-point comparison, in pixel;
	int resolution = 15;

	String message = " ";

	XML xml;
	// dove inizia pannello dx
	int offset = x_dim-x2_dim;
	// dati che servono a disporre i vari pallini
	int X_label_offset = 40;
	int X_label_shift = 100;
	int Y_label_limit = 400;
	int Y_label_offset = 85;
	Label[] labels;
	String buildingtype; 

	public void setup() {
	  size(x_dim, y_dim);
	  textSize(11);
	  // The background image must be the same size as the parameters
	  // into the size() method. In this program, the size of the image
	  // is 640 x 360 pixels.
	  img = loadImage(filename);
	  x = img.width;
	  y = img.height;
	  image(img, 0, 0,x_dim-x2_dim, (x_dim-x2_dim)/x*y);
	  //img.resize(x/10,y/10);
	  //image(img,800,100);
	  fill(100,255,0);
	  //ellipse(offset, 200, 30, 30);
	  //fill(122,11,222);
	  //ellipse(offset,400,30,30);
	  loadData();
	  noLoop();
	  redraw();
	  
	}

	public void draw() {
	  fill(235);
	  rect(0,0,offset,y_dim);
	  if (x > y) {
	    image(img, 0, 0,x_dim-x2_dim, y*(x_dim-x2_dim)/x);
	  }
	  else {
	    image(img, 0, 0,x*y_dim/y, y_dim);
	    //image(img, 0, 0,650 , 400);
	  }
	 // message = Integer.toString(x*y_dim/y);
	  //image(img, 0, 0, 600,650);
	  fill(235);
	  stroke(135);
	  rect(offset,0,x2_dim-2,y_dim);
	  fill(50);
	  textSize(8);
	  text(filename,x_dim-x2_dim/2,70);
	  textSize(11);
	  strokeWeight(3);
	  for (Label l : labels) {
	    l.display();
	    l.rollover(mouseX, mouseY);
	  }
	  strokeWeight(1);
	  // rettangolo di debug
	  fill(220);
	  rect(offset,0,x2_dim -2 ,20);
	  
	  //bottone save;
	  fill(190);
	  rect(offset+30, Y_label_limit+100, x2_dim-60, 30, 5);
	  fill(0);
	  textSize(15);
	  text("save", offset+20+(x2_dim-60)/2, Y_label_limit+120 );
	  
	  fill(190);
	  rect(offset+30, Y_label_limit+150, x2_dim-60, 30, 5);
	  fill(0);
	  text("load", offset+20+(x2_dim-60)/2, Y_label_limit+170 );
	  textSize(11);


	  stroke(10);
	  for (int i=0; i < c.size(); i++)
	    ((Connection) c.get(i)).display();
	  stroke(220);
	  for (int i=0; i < n.size(); i++)
	    ((Node) n.get(i)).display();
	  
	  deb(message);
	  //deb(Integer.toString(mouseX));
	}

	public void mousePressed() 
	{ 
	   
	    boolean found = false;
	  if ((mouseX < offset) && (current_label != -1))  
	  {
	    fill(255);
	    for (int i=0; i < n.size(); i++)
	        if  (n.get(i).occupied(mouseX,mouseY)) {
	          found = true;
	          if (last != -1 ) {
	            n.get(last).setOpacity(Globals.opacity2);
	          }
	          last = lastbu;
	          lastbu = i;
	          n.get(i).setOpacity(Globals.opacity1);
	         break;
	        }
	    if (!found) {
	      ellipse(mouseX,mouseY,10,10);
	      Label l = labels[current_label];
	      n.add(new Node(this, n.size(), mouseX, mouseY, l, current_label, false, l.r, l.g, l.b));
	      last_insert = 1;
	      if (last != -1 ) {
	            n.get(last).setOpacity(Globals.opacity2);
	          }
	      if (lastbu != -1 ) {
	            n.get(lastbu).setOpacity(Globals.opacity2);
	          }
	      last = -1;
	      lastbu = -1;
	    }
	    else {
	      if ((last!=-1) && (lastbu!=-1)) {
	        last_insert = 2;
	        c.add(new Connection(this, last, lastbu, n.get(last).x, n.get(last).y, n.get(lastbu).x, n.get(lastbu).y));
	        n.get(last).setOpacity(Globals.opacity2);
	        n.get(lastbu).setOpacity(Globals.opacity2);
	        last = -1;
	        lastbu = -1;
	      }
	    }
	  }
	  else{
	    
	   last_insert = 0;
	   if ((mouseX >= offset+30) && (mouseX <= offset+x2_dim-30) && (mouseY >= Y_label_limit+100) && (mouseY <= Y_label_limit+130)){
	         saveGraph();
	         message = "saved";
	   }
	   if ((mouseX >= offset+30) && (mouseX <= offset+x2_dim-30) && (mouseY >= Y_label_limit+150) && (mouseY <= Y_label_limit+180)){
	         //loadGraph();  
	         selectInput("Select a file to process:", "fileSelected");
	         message = "loaded";
	   }
	    
	    
	    
	   found = false;
	   int new_selected=-1;
	   // seleziono il colore da mettere giÃ¹
	    for (int i=0; i< labels.length; i++ ) {
	        if (labels[i].occupied(mouseX,mouseY)) {
	          found = true;
	          new_selected = i;
	          break;
	        }
	    }
	    if (found) {
	      if(current_label != -1) {
	        labels[current_label].switch_val();
	      }
	       current_label = new_selected;
	       labels[current_label].switch_val();
	    }
	  }
	  redraw();
	}

	public void keyPressed(){
	  if (key == BACKSPACE) {
	    // last_inser vale 0 se non ho fatto nulla. se vale 1 ho inserito un nodo; se vale 2 ho inserito un arco;
	    switch (last_insert) {
	            case 1:  last_insert = 0;
	                     n.remove(n.size() - 1);
	                     break;
	            case 2:  last_insert = 0;
	                     c.remove(c.size() - 1);
	                     break;
	            default: break;
	          }
	  }
	  else 
	    message = String.valueOf(key);
	  //message = "asdallalla";
	  redraw();
	}

	public void loadData() {

	  int counter = 1;
	  
	  // Load XML file
	  xml = loadXML("labels.xml");
	  XML buildingElement = xml.getChild("buildingtype");
	  XML building_name = xml.getChild("type_name");
	  buildingtype = building_name.getContent();
	  message = buildingtype;
	  
	  XML Xlabels = xml.getChild("labels");
	  XML[] children = Xlabels.getChildren("label");

	  // The size of the array of Bubble objects is determined by the total XML elements named "bubble"
	  labels = new Label[children.length]; 
	  //deb( Integer.toString(labels.length));
	  int xo = X_label_offset  + offset ;
	  int yo = 0;
	  for (int i = 0; i < labels.length; i++) {
	    
	    XML typeElement = children[i].getChild("type");
	    String type = typeElement.getContent();
	    
	    XML nameElement = children[i].getChild("name");
	    String name = nameElement.getContent();
	    
	    // The position element has two attributes: x and y
	    XML colorElement = children[i].getChild("color");
	    // Note how with attributes we can get an integer or float via getInt() and getFloat()
	    int r = colorElement.getInt("r");
	    int g = colorElement.getInt("g");
	    int b = colorElement.getInt("b");

	    if (yo > Y_label_limit) {
	      xo += X_label_shift;
	      counter = 1;
	    }
	    yo = Y_label_offset * counter ;
	    counter ++;
	    // Make a Bubble object out of the data read
	    labels[i] = new Label(this, name, type, r, g, b, Globals.shape*2, xo, yo);
	  }  

	}

	public void fileSelected(File selection) {
	  if (selection == null) {
	    message = "Window was closed or the user hit cancel.";
	  } else {
	    filename  =  selection.getAbsolutePath();
	    message = "loaded";
	    img = loadImage(filename);
	    x = img.width;
	    y = img.height;
	    //image(img, 0, 0,x_dim-x2_dim, (x_dim-x2_dim)/x*y);
	    //image(img, 0, 0, width/10, height/10);
	    redraw();
	  }
	}
	public void saveGraph() {
	  String fileNext = filename.substring(0, filename.lastIndexOf('.')) + ".xml";
	  XML  savedata = new XML("prova");
	  XML nodes = savedata.addChild("nodes");
	  XML connections = savedata.addChild("connections");
	  for (int i=0; i < n.size(); i++) 
	  { 
	    n.get(i).toXML(nodes);      
	  }
	  for (int i=0; i < c.size(); i++) 
	  { 
	    c.get(i).toXML(connections);      
	  }
	  saveXML(savedata, fileNext);
	  message = "lallalalla";

	}
	public void deb(String s) {
	   fill(0);
	   text(s,offset+10+(x2_dim-60)/2,15);
	}
	
}